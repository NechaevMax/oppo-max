═══════════════════════════════════════════════════════════════════════════
                    ДОКУМЕНТАЦИЯ API И ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
═══════════════════════════════════════════════════════════════════════════

СОДЕРЖАНИЕ:
1. Обзор API
2. Примеры использования
3. Обработка исключений
4. Расширение функциональности

═══════════════════════════════════════════════════════════════════════════
1. ОБЗОР API
═══════════════════════════════════════════════════════════════════════════

CLASS: MenuItem
───────────────────────────────────────────────────────────────────────────

ОПИСАНИЕ:
Класс для представления одного элемента меню (блюдо) с названием, ценой
и временем приготовления.

КОНСТРУКТОРЫ:
  MenuItem()
    Параметры: -
    Возвращает: объект с default значениями
    Исключения: -

  MenuItem(const string& name, double price, int cooking_time)
    Параметры:
      - name: название блюда (не может быть пустым)
      - price: цена в рублях (>=0)
      - cooking_time: время приготовления в минутах (>=0)
    Возвращает: объект MenuItem
    Исключения: ValidationException если данные некорректны

МЕТОДЫ ДОСТУПА (Getters):
  const string& getName() const
    Возвращает: название блюда

  double getPrice() const
    Возвращает: цена блюда

  int getCookingTime() const
    Возвращает: время приготовления

МЕТОДЫ УСТАНОВКИ (Setters):
  void setName(const string& n)
    Параметры: новое название
    Исключения: ValidationException если название пусто

  void setPrice(double p)
    Параметры: новая цена
    Исключения: ValidationException если цена < 0

  void setCookingTime(int t)
    Параметры: новое время приготовления
    Исключения: ValidationException если время < 0

ДРУГИЕ МЕТОДЫ:
  void validate() const
    Проверяет корректность всех полей
    Исключения: ValidationException если что-то некорректно

  void print() const
    Выводит информацию о блюде в формате:
    "название: X, цена: Y, время: Z мин"


CLASS: MenuFileReader
───────────────────────────────────────────────────────────────────────────

ОПИСАНИЕ:
Вспомогательный класс для парсинга строк файла меню.
Все методы статические (не требуют создания объекта).

СТАТИЧЕСКИЕ МЕТОДЫ:
  static MenuItem parseMenuItem(const string& line)
    Параметры: строка в формате "menu name="X" price=Y time=Z"
    Возвращает: объект MenuItem с распарсенными данными
    Исключения:
      - ParseException если формат неверный
      - ValidationException если значения некорректны
    
    Формат строки:
      menu name="название" price=цена time=время
    
    Примеры:
      "menu name=\"Борщ\" price=5.5 time=30"
      "menu name=\"Салат Цезарь\" price=7.0 time=10"


CLASS: MenuManager
───────────────────────────────────────────────────────────────────────────

ОПИСАНИЕ:
Основной класс для управления коллекцией блюд меню.

КОНСТРУКТОРЫ:
  MenuManager()
    Создает пустой менеджер меню

МЕТОДЫ:
  void readFromFile(const string& filename)
    Загружает меню из файла
    Параметры: имя файла (например, "menu.txt")
    Исключения:
      - FileException если файл не существует
      - MenuException если меню оказалось пустым
    
    Формат файла: каждая строка в формате, пригодном для parseMenuItem()
    Примечание: пустые строки игнорируются, ошибки парсинга логируются

  void printAll() const
    Выводит все блюда в меню
    Параметры: -
    Исключения: -

  void sortByCookingTime()
    Сортирует блюда по времени приготовления (возрастание)
    Параметры: -
    Исключения: -
    Примечание: После сортировки используйте printAll() для вывода

  void filterByTime(int max_time) const
    Выводит только блюда с временем приготовления <= max_time
    Параметры: максимальное время в минутах
    Исключения: ValidationException если max_time < 0

  void addItemManually()
    Интерактивно добавляет новое блюдо (запрашивает у пользователя)
    Параметры: -
    Исключения: ValidationException если пользователь ввел некорректные данные
    
    Процесс:
      1. Запрашивает название (getline)
      2. Запрашивает цену (cin >>)
      3. Запрашивает время (cin >>)
      4. Добавляет блюдо в меню

  void displayMenu()
    Запускает интерактивное меню с опциями
    Параметры: -
    Исключения: все исключения обрабатываются внутри

    Опции меню:
      1. Вывести все блюда
      2. Вывести отсортировано по времени
      3. Фильтр по времени приготовления
      4. Добавить новое блюдо
      5. Выход


ИЕРАРХИЯ ИСКЛЮЧЕНИЙ:
───────────────────────────────────────────────────────────────────────────

exception (из std)
  └─ MenuException (базовый класс для всех ошибок меню)
      ├─ FileException - ошибки при работе с файлами
      ├─ ParseException - ошибки парсинга данных
      └─ ValidationException - ошибки валидации данных

═══════════════════════════════════════════════════════════════════════════
2. ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
═══════════════════════════════════════════════════════════════════════════

ПРИМЕР 1: Создание элемента меню
───────────────────────────────────────────────────────────────────────────

#include <iostream>
#include "improved_2_LABA.cpp"

int main() {
    try {
        // Создание корректного элемента
        MenuItem borsch("Борщ", 5.5, 30);
        cout << "Создано блюдо: " << borsch.getName() << endl;
        
        // Вывод информации
        borsch.print();
        
        // Изменение цены
        borsch.setPrice(6.0);
        cout << "Новая цена: " << borsch.getPrice() << endl;
        
    } catch (const ValidationException& e) {
        cerr << "Ошибка: " << e.what() << endl;
    }
    return 0;
}

// Вывод:
// Создано блюдо: Борщ
// название: Борщ, цена: 5.5, время: 30 мин
// Новая цена: 6


ПРИМЕР 2: Обработка ошибок валидации
───────────────────────────────────────────────────────────────────────────

try {
    MenuItem invalid("", 5.5, 30);  // Ошибка: пустое название
} catch (const ValidationException& e) {
    cerr << "Ошибка валидации: " << e.what() << endl;
}

try {
    MenuItem invalid2("Борщ", -5.5, 30);  // Ошибка: отрицательная цена
} catch (const ValidationException& e) {
    cerr << "Ошибка валидации: " << e.what() << endl;
}

try {
    MenuItem invalid3("Борщ", 5.5, -30);  // Ошибка: отрицательное время
} catch (const ValidationException& e) {
    cerr << "Ошибка валидации: " << e.what() << endl;
}


ПРИМЕР 3: Парсинг строк меню
───────────────────────────────────────────────────────────────────────────

try {
    string line1 = "menu name=\"Борщ\" price=5.5 time=30";
    MenuItem item1 = MenuFileReader::parseMenuItem(line1);
    item1.print();
    
    string line2 = "menu name=\"Салат Цезарь\" price=7.0 time=10";
    MenuItem item2 = MenuFileReader::parseMenuItem(line2);
    item2.print();
    
} catch (const ParseException& e) {
    cerr << "Ошибка парсинга: " << e.what() << endl;
}

// Вывод:
// название: Борщ, цена: 5.5, время: 30 мин
// название: Салат Цезарь, цена: 7, время: 10 мин


ПРИМЕР 4: Загрузка меню из файла
───────────────────────────────────────────────────────────────────────────

try {
    MenuManager manager;
    
    // Загрузка меню
    manager.readFromFile("menu.txt");
    cout << "Меню загружено успешно!" << endl;
    
    // Вывод всех блюд
    cout << "\n=== ВСЕ БЛЮДА ===" << endl;
    manager.printAll();
    
} catch (const FileException& e) {
    cerr << "Ошибка файла: " << e.what() << endl;
} catch (const ParseException& e) {
    cerr << "Ошибка парсинга: " << e.what() << endl;
} catch (const MenuException& e) {
    cerr << "Ошибка меню: " << e.what() << endl;
}


ПРИМЕР 5: Сортировка меню
───────────────────────────────────────────────────────────────────────────

try {
    MenuManager manager;
    manager.readFromFile("menu.txt");
    
    // Сортировка по времени приготовления
    manager.sortByCookingTime();
    
    cout << "\n=== ОТСОРТИРОВАНО ПО ВРЕМЕНИ ===" << endl;
    manager.printAll();
    
} catch (const MenuException& e) {
    cerr << "Ошибка: " << e.what() << endl;
}

// Вывод (если в menu.txt есть):
// название: Салат Цезарь, цена: 7, время: 10 мин
// название: Пельмени, цена: 4, время: 15 мин
// название: Стейк, цена: 12.5, время: 25 мин
// название: Борщ, цена: 5.5, время: 30 мин


ПРИМЕР 6: Фильтрация по времени
───────────────────────────────────────────────────────────────────────────

try {
    MenuManager manager;
    manager.readFromFile("menu.txt");
    
    int max_time = 20;
    cout << "\n=== БЛЮДА С ВРЕМЕНЕМ <= " << max_time << " МИН ===" << endl;
    manager.filterByTime(max_time);
    
} catch (const MenuException& e) {
    cerr << "Ошибка: " << e.what() << endl;
}

// Вывод (если в menu.txt есть):
// название: Салат Цезарь, цена: 7, время: 10 мин
// название: Пельмени, цена: 4, время: 15 мин


ПРИМЕР 7: Полная обработка с иерархией исключений
───────────────────────────────────────────────────────────────────────────

try {
    MenuManager manager;
    manager.readFromFile("menu.txt");
    manager.displayMenu();
    
} catch (const FileException& e) {
    cerr << "Ошибка открытия файла: " << e.what() << endl;
    return 1;
} catch (const ParseException& e) {
    cerr << "Ошибка парсинга данных: " << e.what() << endl;
    return 2;
} catch (const ValidationException& e) {
    cerr << "Ошибка валидации данных: " << e.what() << endl;
    return 3;
} catch (const MenuException& e) {
    cerr << "Ошибка меню: " << e.what() << endl;
    return 4;
} catch (const exception& e) {
    cerr << "Неизвестная ошибка: " << e.what() << endl;
    return 5;
}

return 0;

═══════════════════════════════════════════════════════════════════════════
3. ОБРАБОТКА ИСКЛЮЧЕНИЙ
═══════════════════════════════════════════════════════════════════════════

РЕКОМЕНДАЦИИ ПО ОБРАБОТКЕ:

1. Специфичные исключения перехватывайте первыми:
   try {
       // код
   } catch (const FileException& e) {
       // обработать ошибку файла
   } catch (const ParseException& e) {
       // обработать ошибку парсинга
   } catch (const ValidationException& e) {
       // обработать ошибку валидации
   } catch (const MenuException& e) {
       // обработать прочие ошибки меню
   } catch (const exception& e) {
       // обработать неизвестные ошибки
   }

2. Используйте информативные сообщения об ошибках:
   cout << "Ошибка: " << e.what() << endl;

3. При необходимости восстановления используйте throw в блоке catch:
   try {
       // код
   } catch (const ParseException& e) {
       cerr << "Ошибка парсинга, пропускаю строку: " << e.what() << endl;
       // продолжить выполнение
   }

4. Для критичных ошибок выходите из программы:
   try {
       manager.readFromFile("menu.txt");
   } catch (const FileException& e) {
       cerr << "Критическая ошибка: " << e.what() << endl;
       return 1;  // Выход с кодом ошибки
   }

═══════════════════════════════════════════════════════════════════════════
4. РАСШИРЕНИЕ ФУНКЦИОНАЛЬНОСТИ
═══════════════════════════════════════════════════════════════════════════

ДОБАВЛЕНИЕ НОВЫХ ТИПОВ ИСКЛЮЧЕНИЙ:
───────────────────────────────────────────────────────────────────────────

Создайте новый класс, наследующий MenuException:

class StorageException : public MenuException {
public:
    explicit StorageException(const string& reason) 
        : MenuException("Ошибка сохранения: " + reason) {}
};

Теперь используйте его:

try {
    saveMenuToFile("output.txt");
} catch (const StorageException& e) {
    cerr << "Ошибка сохранения: " << e.what() << endl;
} catch (const MenuException& e) {
    cerr << "Ошибка меню: " << e.what() << endl;
}


ДОБАВЛЕНИЕ НОВЫХ МЕТОДОВ К MenuItem:
───────────────────────────────────────────────────────────────────────────

class MenuItem {
    // ... существующий код ...
    
    // Новый метод: получить описание
    string getDescription() const {
        ostringstream ss;
        ss << getName() << " (" << getCookingTime() << " мин) - "
           << getPrice() << " руб.";
        return ss.str();
    }
    
    // Новый метод: сравнение по цене
    bool isCheaperThan(double max_price) const {
        return price_ < max_price;
    }
};


ДОБАВЛЕНИЕ НОВОГО МЕТОДА К MenuManager:
───────────────────────────────────────────────────────────────────────────

class MenuManager {
    // ... существующий код ...
    
    // Новый метод: фильтрация по цене
    void filterByPrice(double max_price) const {
        if (max_price < 0) {
            throw ValidationException("max_price - цена не может быть отрицательной");
        }
        
        bool found = false;
        for (const auto& item : items_) {
            if (item.getPrice() <= max_price) {
                item.print();
                found = true;
            }
        }
        
        if (!found) {
            cout << "Блюд с ценой <= " << max_price << " руб. не найдено\n";
        }
    }
    
    // Новый метод: добавить блюдо без проверки (опасно!)
    void addItemUnsafe(const MenuItem& item) {
        items_.push_back(item);
    }
};

═══════════════════════════════════════════════════════════════════════════

Подробная документация по каждому классу находится в исходном коде с комментариями.
